/*
 * @(#)KnotApplet.java
 *
 * $Date: 2015-02-28 21:59:45 +0100 (Sa, 28 Feb 2015) $
 *
 * Copyright (c) 2013 by Jeremy Wood.
 * All rights reserved.
 *
 * The copyright of this software is owned by Jeremy Wood. 
 * You may not use, copy or modify this software, except in  
 * accordance with the license agreement you entered into with  
 * Jeremy Wood. For details see accompanying license terms.
 * 
 * This software is probably, but not necessarily, discussed here:
 * https://javagraphics.java.net/
 * 
 * That site should also contain the most recent official version
 * of this software.  (See the SVN repository for more details.)
 */
package com.bric.geom.knot;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.geom.Ellipse2D;
import java.awt.geom.RoundRectangle2D;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import javax.swing.JCheckBoxMenuItem;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.event.MouseInputAdapter;

import com.bric.blog.Blurb;
import com.bric.blog.ResourceSample;
import com.bric.swing.BricApplet;

/** This explores how to render some celtic knots. (A reader wrote with some questions.)
 *
 * 
 * <!-- ======== START OF AUTOGENERATED SAMPLES ======== -->
 * <p><img src="https://javagraphics.java.net/resources/samples/KnotApplet/sample.png" alt="new&#160;com.bric.geom.knot.KnotApplet()">
 * <!-- ======== END OF AUTOGENERATED SAMPLES ======== -->
 */
@Blurb (
filename = "KnotApplet",
title = "Shapes: Experimenting with Knots",
releaseDate = "TBA",
summary = "This explores how to render some celtic knots. (A reader wrote with some questions.)",
instructions = "Click and drag the shapes around.",
scrapped = "I never bothered to write this up or fine-tune it. I think I helped answer the reader's questions, though.",
sandboxDemo = true
)
@ResourceSample( sample="new com.bric.geom.knot.KnotApplet()" )
public class KnotApplet extends BricApplet {
	private static final long serialVersionUID = 1L;
		
	public static void main(String[] args) {
		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				try {
					String lf = UIManager.getSystemLookAndFeelClassName();
					UIManager.setLookAndFeel(lf);
				} catch (Throwable e) {
					e.printStackTrace();
				}
				
				JFrame f = new JFrame();
				f.getContentPane().add(new KnotApplet());
				f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				f.pack();
				f.setVisible(true);
			}
		});
	}
	
	class PreviewPanel extends JPanel {
		private static final long serialVersionUID = 1L;
		
		MouseInputAdapter mouseListener = new MouseInputAdapter() {
			int lastX, lastY;
			int selectedShape = -1;

			@Override
			public void mouseDragged(MouseEvent e) {
				int x = e.getX();
				int y = e.getY();
				if(selectedShape!=-1) {
					int dx = x - lastX;
					int dy = y - lastY;
					shapes[selectedShape].dx += dx;
					shapes[selectedShape].dy += dy;
					lastX = x;
					lastY = y;
					updateData();
				}
			}
			
			protected void showPopupMenu(MouseEvent e) {
				menu.show(PreviewPanel.this, e.getX(), e.getY());
			}

			@Override
			public void mouseReleased(MouseEvent e) {
				if(e.isPopupTrigger()) {
					showPopupMenu(e);
				}
			}

			@Override
			public void mousePressed(MouseEvent e) {
				if(e.isPopupTrigger()) {
					showPopupMenu(e);
				}
				selectedShape = -1;
				int x = e.getX();
				int y = e.getY();
				for(int a = shapes.length-1; a>=0 && selectedShape==-1; a--) {
					if(shapes[a].contains(x,y)) {
						selectedShape = a;
						lastX = x;
						lastY = y;
					}
				}
			}
		};
		
		Collection<Intersection> intersections = new HashSet<Intersection>();

		JPopupMenu menu = new JPopupMenu();
		JCheckBoxMenuItem item = new JCheckBoxMenuItem("Debug", debug);
		
		PreviewPanel() {
			setPreferredSize(new Dimension(320, 320));
			addMouseListener(mouseListener);
			addMouseMotionListener(mouseListener);
			updateData();

			item.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					debug = !debug;
					repaint();
				}
			});
			menu.add(item);
		}
		
		protected void updateData() {
			intersections.clear();
			for(int a = 0; a<shapes.length; a++) {
				for(int b = a+1; b<shapes.length; b++) {
					shapes[a].getIntersections(shapes[b], intersections);
				}
			}
			repaint();
		}
		
		class ShapeComparator implements Comparator<Intersection> {
			RenderedShape shape;
			ShapeComparator(RenderedShape shape) {
				this.shape = shape;
			}

			public int compare(Intersection i1, Intersection i2) {
				if(i1.shape1!=shape)
					throw new RuntimeException();
				if(i2.shape1!=shape)
					throw new RuntimeException();
				
				if(i1.seg1<i2.seg1)
					return -1;
				if(i1.seg1>i2.seg1)
					return 1;

				if(i1.t1<i2.t1)
					return -1;
				if(i1.t1>i2.t1)
					return 1;
				
				return 0;
			}
			
		}
		
		protected SortedSet<Intersection> getIntersections(RenderedShape shape) {
			SortedSet<Intersection> dest = new TreeSet<Intersection>(new ShapeComparator(shape));
			Iterator<Intersection> iter = intersections.iterator();
			while(iter.hasNext()) {
				Intersection i = iter.next();
				if(i.shape1==shape) {
					dest.add(i);
				} else if(i.shape2==shape) {
					dest.add(i.createInverse());
				}
			}
			return dest;
		}
		
		protected void paintComponent(Graphics g) {
			super.paintComponent(g);
			for(int a = 0; a<shapes.length; a++) {
				shapes[a].paint(g);
			}
			Set<Intersection> processedIntersections = new HashSet<Intersection>();
			for(int a = 0; a<shapes.length; a++) {
				SortedSet<Intersection> shapeIntersections = getIntersections( shapes[a] );

				int overValue = 0;
				Iterator<Intersection> iter = shapeIntersections.iterator();
				int ctr = 0;
				while(iter.hasNext()) {
					Intersection intersection = iter.next();
					if(intersection.shape1Over!=null) {
						if(intersection.shape1Over) {
							overValue = ctr%2;
						} else {
							overValue = (ctr+1)%2;
						}
					}
					ctr++;
				}
				
				
				iter = shapeIntersections.iterator();
				ctr = 0;
				while(iter.hasNext()) {
					Intersection intersection = iter.next();
					if(!processedIntersections.contains(intersection)) {
						if(ctr%2==overValue) {
							intersection.shape1.paint(g, intersection.x, intersection.y, intersection.shape2, debug);
							intersection.shape1Over = Boolean.TRUE;
						} else {
							intersection.shape2.paint(g, intersection.x, intersection.y, intersection.shape1, debug);
							intersection.shape1Over = Boolean.FALSE;
						}
						processedIntersections.add(intersection);
						processedIntersections.add(intersection.createInverse());
					}
					ctr++;
				}
			}
			
			if(debug) {
				Iterator<Intersection> iter = intersections.iterator();
				g.setColor(Color.red);
				while(iter.hasNext()) {
					Intersection intersection = iter.next();
					g.fillOval( (int)(intersection.x-3), (int)(intersection.y-3), 6, 6 );
				}
			}
		}
	}
	
	RenderedShape shape1 = new RenderedShape(new Ellipse2D.Float(40+20,40+20,200,200), new Color(0x888899));
	RenderedShape shape2 = new RenderedShape(new RoundRectangle2D.Float(100+20,0+20,80,280,4,4), new Color(0x889988));
	RenderedShape shape3 = new RenderedShape(new RoundRectangle2D.Float(0+20,100+20,280,80,4,4), new Color(0x998888));

	boolean debug = false;
	
	RenderedShape[] shapes = new RenderedShape[] { shape1, shape2, shape3 };
	
	PreviewPanel previewPanel = new PreviewPanel();
	
	public KnotApplet() {
		add(previewPanel);
	}
}
